# How to read this file?
This file is meant to be a complete specification
of the memory modules, in contrast with the README file,
which is a layout of functionality.

## Memory Instructions Specification
One of the divisions of ARM assembly code instructions is the group of instructions which interact with memory. The modules named `LDRSTR` and `LDMSTM` simulate this group. More specifically, they simulate loading and storing from/to memory, by accessing the memory registers at the address generated by the instruction. Both of these modules are coupled with their respective testing modules, namely `testLDRSTR` and `testLDMSTM`. The specification of all these modules follows:

### 1. LDRSTR
#### 1.1 Functionality
The LDRSTR module fully parses and fully executes/simulates the following assembly code instructions:
- `LDR (Load from memory with register offset)`
- `STR (Store to memory with register offset)`
- `LDRB (Byte memory address version of LDR)`
- `STRB (Byte memory address version of STR)`
, with "fully" being used to indicate that both parsing and execution functions adhere to the [ARM Infocenter](http://infocenter.arm.com/help/topic/com.arm.doc.dui0552a/BABFGBDD.html) specification on the above instructions. 
 
#### 1.2 Interfaces - Operation inside Project
Inside the scope of the whole project, LDRSTR can be seen as two functions, parse and execute. These functions can be called by the top level module using the following interface:
- parse interface:  
 `ls: LineData -> Result<Parse<Instr,Err> option`
 - execute interface:
`DataPath -> MachineMemory<Instr> -> Instr -> Result<(MachineMemory<Instr> * DataPath),Err>`
,where Instr is defined inside the module.
NB: Parse can also be called through the active pattern `IMatch`. 
#### 1.3 Dependencies
The module depends on modules CommonData and CommonLex which provide it with types. In case these modules are amended, correct operation of LDRSTR cannot be guaranteed. 
It also depends on the following packages:
-  .NETFramework\v4.6.1 
-   Expecto.7.0.0 (for testingLDRSTR), and
-   Mono.Cecil.0.10.0-beta7 (mandatory for Expecto) 

#### 1.4 Operation
Function `parse` is responsible for transforming a string which represents an assembly code instruction into the Disjointed Union `Instr`, which is returned to the caller after being wrapped in a Parse, Result and Option type as shown below:
`Result<Parse<Instr,Err> option`

Function `execute` is responsible for simulating the given `Instr` D.U. to resemble the execution of a real instruction in an ARM processor. Essentially, it decodes the `Instr` and changes the state of the CPU and Memory accordingly by loading/storing operations.

#### 1.5 Implementation Progress

| Instruction Variant | Feature | Parsing | Execution | Unit Test |  
|:---:|:---|:---:|:---:|:---:|
| `{LDR|STR} Rd, [Rn{, #{+|-}<12 bit offset>}]` | Immediate Offset | ✔️ | ✔️ | ✔️ |
| `{LDR|STR} Rd, [Rn, {+|-}Rm]` | Register Offset | ✔️ | ✔️ | ✔️ |
| `{LDR|STR}     Rd, [Rn, {+|-}Rm, <shift> #<shift immediate>]` | Scaled register Offset | ✔️| ✔️ | ✔️ |
| `{LDR|STR}     Rd, [Rn #{+|-}<12 bit offset>]!` | Immediate Pre-indexed | ✔️ | ✔️ | ✔️ |
| `{LDR|STR}     Rd, [Rn, {+|-}Rm]!` | Register Pre-indexed | ✔️ | ✔️ | ✔️ |
| `{LDR|STR}     Rd, [Rn, {+|-}Rm, <shift> #<shift immediate>]!` | Scaled register Pre-indexed | ✔️| ✔️ | ✔️ |
| `{LDR|STR}  Rd, [Rn], #{+|-}<12 bit offset>` | Immediate Post-indexed | ✔️| ✔️ | ✔️ |
| `{LDR|STR}  Rd, [Rn], {+|-}Rm` | Register Post-indexed | ✔️ | ✔️ | ✔️ |
| `{LDR|STR}  Rd, [Rn], {+|-}Rm, <shift> #<shift immediate>` | Scaled register Post-indexed | ✔️ | ✔️ | ✔️ |
| `{LDR|STR}{B}  ...` | All Byte Addressed Versions | ❌| ❌ | ❌

#### 1.6 Implementation Specification (for developers)
**Types**
1. `type Instr`: contains all necessary information extracted from parsing an assembly code line
2. `type Literal` : accounts for offset on address contained in register
3. `type MemInstrClass` : distinguishes between store and load
4. `type MemInstrOffset`: distinguishes between different types of offsets on address contained in register
5.  `type MemInstrIndex`: specifies whether offset is applied before or after memory operation
6. `type Err`: is returned to top level from either execution or parsing if:
- an invalid operation is asked to be carried out, or
- user has provided invalid input
- code fails and error is successfully handled

**Function Pipeline**
- #### Parsing
 `parse` function receives `LineData` and disassembles its fields, distributing `root, suffix, operands` to `parseMemInstr`. The latter performs the main parsing. 
 
`parseMemInstr` builds a type of `MemInstr`. It first matches the root and the suffix. Then, it calls `parseMemOps` to parse the operands. The returned parse operands go to the fields of `MemInstr`.

`parseMemOps` does the bulk of it's parsing through regular expression matching of the operand strings. It does this using the active pattern defined as `let (|Regex|_|) pattern input`. The active pattern returns matched groups which are subsequently passed to "validate functions" to ensure correctness.

The end result of parsing is a `Result<Parse<Instr>,Err> option` that can then be fed through to execution. The option type will return `None` if the operational code fails to match and the result type will return Err in the cases specified in the "Types" section above. 

- #### Execution (NEEDS FORMATTING)

`execute` handles the bulk of it's operations within its body.

It first converts the `Offset` type to a `uint32` which can then be combined with the `addr` register value with the corresponding `+` or `-` according to the instruction.

After matching on the instruction class (`LDR` or `STR`) either a register or memory search occurs, returning error on `None` being returned.

Pre/Post Indexing is dealt with during this process, and the `addr` register is updated at then end accordingly.

The return output is a `Result<CompleteData<Instr>,Err>`

### 2. TestLDRSTR
The following section concerns the `TestLDRSTR` module, whose purpose is to test the `LDRSTR` 's parse and execute functions for potential malfunctions. The basic testing method is unit-Testing on corner cases. A complete testcase table can be found below.
#### 2.1 Features tested
| Instruction | Variant | Cornercase description |Tested? |  
|:---:|:---|:---:|:---:|
|Parse|LDR|No Offset added|:heavy_check_mark:|
|Parse|LDR|Immediate Offset added|:heavy_check_mark:|
|Parse|LDR|Register Offset added|:heavy_check_mark:|
|Parse|LDR|Shifted Offset added|:heavy_check_mark:|
|Parse|LDR|Check Hex/Bin and +/- parsing|:heavy_check_mark:|
|Execute|LDR|No Offset added|:heavy_check_mark:|
|Execute|STR|No Offset added|:heavy_check_mark:|
|Execute|LDR|Immediate Offset added|:heavy_check_mark:|
|Execute|LDR|Register Offset added|:heavy_check_mark:|
|Execute|LDR|Shifted Offset added|:heavy_check_mark:|
|Execute|LDRB|Byte Addressing|:heavy_check_mark:|
|Execute|STRB|Byte Addressing|:heavy_check_mark:|
|Execute|LDRB|Byte Addressing error check|:heavy_check_mark:|
#### 2.2 Testing Implementation (for developers)

TestLDRSTR uses the `Expecto` testing package. It creates a list of tests which are all run by the `runTestsInAssembly` function. The tests are unit case tests, all contained in the `testUnitParseMemInstr` and `testUnitExecMemInstr` function, for parsing and execution respectively. In these function the programmer inputs manually all the different cases in the form of a tuple: `(input to function,expected output)`. For the execution testing, the user also needs to provide the memory state and the dataPath state of the machine. Finally, the  `Expect.equal (func inp) outp testName` checks if the function output is equal to the expected one after each test and reports it to the user accordingly. 

NB: Execute testing first parses string and then executes it.

### 1&2. Future Work
-Property based testing, specifiicaly regarding offset values
-Make small changes to provided VisualTest code to use for generating outputs to compare against for MEM instrutions
-Implemnet byte addressing for LDR and STR

### 3. LDMSTM

#### 3.1 Functionality
The LDMSTM module fully parses and fully executes/simulates the following assembly code instructions:
- `LDM{suffix} (Loads multiple memory locations to registers)`
- `STM{suffix} (Stores multiple registers values to memory)` 
, with "fully" being used to indicate that both parsing and execution functions adhere to the [ARM Infocenter](http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0552a/BABCAEDD.html) specification on the above instructions. 
The module correctly handles all possible suffixes: EA, ED, FA, FD and their respective aliases DB, DA, IB, IA.
Note that the LDM and STM instructions are usually connected to the idea of the stack because their most common use is with subroutines, where the stack pointer is used to point at the current address of the stack. When the subroutine is called chosen registers are stored into stack memory and when subroutine finishes they are loaded again to preserve the state of the program before subroutine was called. However, they can be used as regular multiple load and store instructions as well.
 
 
#### 3.2 Interfaces - Operation inside Project
Inside the scope of the whole project, LDMSTM can be seen as two functions, parse and execute. These functions can be called by the top level module using the following interface:
- parse interface:  
 `ls: LineData -> Result<Parse<Instr,Err> option`
 - execute interface:
`DataPath -> MachineMemory<Instr> -> Instr -> Result<(MachineMemory<Instr> * DataPath),Err>`
,where Instr is defined inside the module.
NB: Parse can also be called through the active pattern `IMatch`. 
#### 3.3 Dependencies
The module depends on modules:
-  CommonData 
-  CommonLex, and
- EEExtensions (functions operating on strings and regular expressions)

which provide it with types and functions. In case these modules are amended, correct operation of LDMSTM cannot be guaranteed. 
It also depends on the following packages:
-  .NETFramework\v4.6.1  

#### 3.4 Operation
Function `parse` is responsible for transforming a string which represents an assembly code instruction into the Disjointed Union `Instr`, which is returned to the caller after being wrapped in a Parse, Result and Option type as shown below:
`Result<Parse<Instr,Err> option`

Function `execute` is responsible for simulating the given `Instr` D.U. to resemble the execution of a real instruction in an ARM processor. Essentially, it decodes the `Instr` and changes the state of the CPU and Memory accordingly by loading/storing operations.

#### 3.5 Implementation Progress

It is risky but it will be claimed that ALL VARIANTS of the LDM and STM instructions have been implemented and **meticulously** tested. Hence, they have full functionality again as specified by the ARM Infocenter.

#### 3.6 Implementation Specification (for developers)
**Types**
1. `type Instr`: contains all necessary information extracted from parsing an assembly code line
2. `type Tokens` : used to transform string into token list which is subsequently parsed easier than a string would
3. `type Root` : distinguishes between STM and LDM
4. `type Suffix`: distinguishes between different types of suffixes
5.  `type UpdatePointer`: specifies whether pointer should be updated
6. `type Err`: is returned to top level from either execution or parsing if:
- an invalid operation is asked to be carried out, or
- user has provided invalid input
- code fails and error is successfully handled

**Function Pipeline**
- ### Parsing
 `parse` function receives `LineData` and disassembles its fields, distributing `root, suffix, op1 and op2` to the functions `parseOpCode`, `parseFstOp` and `parseSndOp`. In this way, the operational code, the first operand and the second operand are parsed separately. 

The pipelined 
`parseOpCode root suffix`
`|> Result.bind (parseFstOp op1)`
`|> Result.bind (parseSndOp op2)`
does the basic parsing. `parseOpCode` creates a dummy `Instr` and fills it with the parsed operational code. Then it passes it to parseFstOp, which adds the parsed first operand. Finally, the result of the latter is passed to the final parseSndOp function which adds the cherry on the cake (parsed second operand to Instr) to return a fully parsed `Instr`.

Both `parseFstOp` and `parseSndOp` follow the same parsing technique, namely they first tokenize the string and then they parse the Token list. The parsing of the Tokens is done recursively in both functions. The tokenizing is done through regular expression matching of the operand strings. It does this using the active pattern defined as `let (|StringMatch|_|) regex str`, which can be found in EEExtensions. The active pattern returns the matched string and the list of matched group, but only the matched string is used in the code.

The end result of parsing is a `Result<Parse<Instr>,Err> option` that can then be fed through to execution. The option type will return `None` if the operational code fails to match and the result type will return Err in the cases specified in the "Types" section above. 

- ### Execution

`execute` handles all of it's operations within its body.

The two `basicOperation` functions recursively store/load from/to memory/registers to registers/memory. They iterate until register list is empty. They update the memory and register states and return the final states to the caller. The caller is `memoryTopOperation`, a **high order function** which controls the inputs to the `basicOperation` functions as explained below.

The `execute` function takes advantage of the common functionality of the different stack directions (EA,ED,FA,FD). The `basicOperation` functions have **modes of operation** which change according to the suffix of the load/store instruction. The **change of mode** is dictated by the function `setPointerDir` which is passed as an argument to them. So, the input function `setPointerDir` sets the mode of `basicOperation` according to instruction, more specifically: 
This function: 
- switches from Ascending to Descending stack pointer
- increments the starting stack pointer or decrements it
-  changes the value of the final iteration return value to update the pointer correctly because otherwise the pointer in the end would be one more address up/down than desirable.

Finally, the changed memory and `dataPath` states are returned to the top level caller in a `Result<(MachineMemory<Instr> * DataPath),Err>` type to account for potential errors during operation.


### 4. TestLDMSTM
The following section concerns the `TestLDMSTM` module, whose purpose is to test the `LDMSTM` 's parse and execute functions for potential malfunctions. The basic testing method is unit-Testing on corner cases. A complete testcase table can be found below. 

#### 4.1 Features tested
| Instruction | Variant | Cornercase description |Tested? |  
|:---:|:---|:---:|:---:|
|Parse|STMEA|Simple Correct Instr|✔️|
|Parse|LDMEA|Simple Correct Instr|✔️|
|Parse|STREA|Wrong Root Detection|✔️|
|Parse|STMEF|Wrong Suffix Detection|✔️|
|Parse|STMEA23|Wrong Condition Detection|✔️|
|Parse|EASTMEQ|Swapping Root-Suffix Detection|✔️|
|Parse|STM/LDM|First Operand Wrong Detection (7 ways)|✔️|
|Parse|STM/LDM|PC cannot be first operand|✔️|
|Parse|STM|Second Operand Wrong Detection (5 ways)|✔️|
|Parse|STM/LDM|SndOp cannot contain SP|✔️|
|Parse|STM/LDM|SndOp cannot contain PC|✔️|
|Parse|LDM|LDM must NOT contain PC IF it contains LR|✔️|
|Parse|STM/LDM|{regList} must not contain Pointer register if writeback suffix is asserted|✔️|
|Parse|ALL SUFFIX VARIATIONS FOR STM/LDM|Correct Instructions|✔️|
|Parse|ALL SUFFIX ALIASES VARIATIONS FOR STM/LDM|Correct Instructions|✔️|
|Parse|ALL REGISTER ALIASES VARIATIONS FOR STM/LDM|Correct Instructions|✔️|
|Execute|ALL VARIATIONS OF ALL SUFFIXES FOR BOTH STM AND LDM|Correct Instructions|✔️(17 tests)|
|Execute|STM/LDM|Accessing Code Memory Error|✔️|
|Execute|STM/LDM|Invalid Address (not div by 4) error|✔️|

#### 4.2 Testing Implementation (for developers)

TestLDMSTM does not use `Expecto` but a user-made testing framework. The general idea is to perform unit tests by creating a list of tuples containing (input to function to be tested, expected output) and then to test if the output of the function to be tested is equal to the specified expected output. Due to the nature of the module, if testing works in one case it is extremely likely to work in all other cases (eg. different register) except from the corner cases. Therefore, the module tests all corner cases and one or two simple correct instructions of all variants.

**Testing parse**
`listCornerCases` is the list explained in the paragraph above specific to parsing. 
`testParseTopFunction` is the actual testing function which calls the function `parse` with the input from `listCornerCases` and compares the obtained output with the user specified expected output again in the list. It filters out the list, keeps the tests that failed and displays them.
**Testing execute**
`executionExpectedOutput` and `testExecutionTopFunction` are the execution equivalents of `listCornerCases` and `testParseTopFunction`. The only difference is that execution testing needs the dataPath and the memory states defined both before and after each execution. This was not done in an automatic way but with boilerplate code by setting the state for each test.  

### 3&4. Future Work
- Include PUSH and POP pseudo-instructions
- Create a huge assembly code which operates hundreds of consecutive store and load instructions. Run it and then check against visUAL a number of times. After so many instructions, it is unlikely the two outputs will agree in the existence of an error
